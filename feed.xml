<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://r4hul77.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://r4hul77.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-08-24T20:34:23+00:00</updated><id>https://r4hul77.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Setting Up SDKManager on Any Linux Distro</title><link href="https://r4hul77.github.io/blog/2024/DockerSdkManger/" rel="alternate" type="text/html" title="Setting Up SDKManager on Any Linux Distro"/><published>2024-08-24T14:14:16+00:00</published><updated>2024-08-24T14:14:16+00:00</updated><id>https://r4hul77.github.io/blog/2024/DockerSdkManger</id><content type="html" xml:base="https://r4hul77.github.io/blog/2024/DockerSdkManger/"><![CDATA[<h1 id="flashing-jetson-devices-on-any-linux-distro-using-docker">Flashing Jetson Devices on Any Linux Distro Using Docker</h1> <p>NVIDIA’s Jetson series represents the cutting edge of embedded computing, offering powerful processing capabilities for AI, robotics, and more. However, flashing the latest JetPack on a Jetson device traditionally requires an Ubuntu machine—specifically one older than version 22.04. For many, this is far from ideal.</p> <p>In this guide, I’ll show you how to bypass this limitation by setting up a Docker container with a GUI, allowing you to flash your Jetson device regardless of your host Linux distribution. Let’s dive in!</p> <h2 id="step-1-download-sdkmanager">Step 1: Download SDKManager</h2> <p>First, download the latest version of SDKManager from the <a href="https://developer.nvidia.com/sdk-manager">NVIDIA Developer website</a>. Rename the file to <code class="language-plaintext highlighter-rouge">sdkmanager.deb</code> for convenience.</p> <h2 id="step-2-build-the-docker-image">Step 2: Build the Docker Image</h2> <p>Next, we’ll create a Docker image that can run SDKManager with a GUI interface. Follow these steps:</p> <ol> <li>On your Ubuntu machine, create a new directory and move the <code class="language-plaintext highlighter-rouge">sdkmanager.deb</code> file into it.</li> <li>Create a Dockerfile in the same directory and name it <code class="language-plaintext highlighter-rouge">sdkmanager.Dockerfile</code>.</li> <li> <p>Copy the following contents into <code class="language-plaintext highlighter-rouge">sdkmanager.Dockerfile</code>:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c"># Use the official Ubuntu 22.04 as a parent image</span>
 FROM ubuntu:22.04

 <span class="c"># Set environment variables to avoid prompts during package installation</span>
 ENV DEBIAN_FRONTEND=noninteractive

 <span class="c"># Update the package list and install essential packages</span>
 RUN apt-get update &amp;&amp; \
     apt-get install -y --no-install-recommends \
     build-essential \
     curl \
     wget \
     vim \
     git \
     ca-certificates \
     software-properties-common &amp;&amp; \
     apt-get clean &amp;&amp; \
     rm -rf /var/lib/apt/lists/*


 WORKDIR /workspace
 COPY sdkmanager_2.1.0-11698_amd64.deb sdkmanger.deb

 RUN apt update &amp;&amp; chmod 777 sdkmanger.deb &amp;&amp; apt-get install -y ./sdkmanger.deb


 RUN apt-get -y install \
     firefox \
     libcanberra-gtk-module \
     libcanberra-gtk3-module
 <span class="c"># Set the working directory</span>

 ARG USERNAME=non-root
 ARG USER_UID=1000
 ARG USER_GID=$USER_UID

 <span class="c"># Create the user</span>
 RUN groupadd --gid $USER_GID $USERNAME \
     &amp;&amp; useradd --uid $USER_UID --gid $USER_GID -m $USERNAME \
     #
     # [Optional] Add sudo support. Omit if you don't need to install software after connecting.
     &amp;&amp; apt-get update \
     &amp;&amp; apt-get install -y sudo \
     &amp;&amp; echo $USERNAME ALL=\(root\) NOPASSWD:ALL &gt; /etc/sudoers.d/$USERNAME \
     &amp;&amp; chmod 0440 /etc/sudoers.d/$USERNAME

 <span class="c"># ********************************************************</span>
 <span class="c"># * Anything else you want to do like clean up goes here *</span>
 <span class="c"># ********************************************************</span>

 <span class="c"># [Optional] Set the default user. Omit if you want to keep the default as root.</span>
 USER $USERNAME
</code></pre></div> </div> </li> </ol> <p>This Dockerfile sets up an Ubuntu 22.04 environment, installs SDKManager, and creates a non-root user to avoid permission issues during flashing.</p> <ol> <li> <p>To build the Docker image, open a terminal in the same directory and run:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> docker build <span class="nt">-t</span> sdkmanager:latest <span class="nb">.</span> <span class="nt">--file</span> sdkmanager.Dockerfile
</code></pre></div> </div> </li> </ol> <h2 id="step-3-run-the-docker-image">Step 3: Run the Docker Image</h2> <p>Now that we have our Docker image, let’s run it. We’ll create a bash script to simplify the process.</p> <ol> <li> <p>In the same directory, create a new file named <code class="language-plaintext highlighter-rouge">sdkmanager.sh</code> and paste the following script:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c">#!/bin/bash</span>
 xhost +
 docker run <span class="nt">-it</span> <span class="nt">--privileged</span> <span class="nt">-v</span> /dev/bus/usb:/dev/bus/usb/ <span class="nt">-v</span> /dev:/dev <span class="nt">-v</span> /media/<span class="nv">$USER</span>:/media/nvidia:slave <span class="nt">--network</span> host <span class="nt">-e</span> <span class="nv">DISPLAY</span><span class="o">=</span><span class="nv">$DISPLAY</span> <span class="nt">-v</span> /tmp/.X11-unix:/tmp/.X11-unix sdkmanager:latest
</code></pre></div> </div> </li> <li> <p>Make the script executable:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">chmod</span> +x sdkmanager.sh
</code></pre></div> </div> </li> <li> <p>To run the Docker container, simply execute:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> bash sdkmanager.sh
</code></pre></div> </div> </li> </ol> <p>Once inside the container, start SDKManager by running:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sdkmanager
</code></pre></div></div> <p>Follow the on-screen instructions to flash your Jetson device. Happy flashing!</p>]]></content><author><name></name></author><category term="Jetson"/><category term="Robotics,"/><category term="Networking,"/><category term="Debugging,"/><category term="Jetson,"/><category term="Docker"/><summary type="html"><![CDATA[A Quick Guide to Setting Up Docker for Jetson Flashing]]></summary></entry><entry><title type="html">Sharing Internet Connection with Embedded Devices</title><link href="https://r4hul77.github.io/blog/2024/wifi/" rel="alternate" type="text/html" title="Sharing Internet Connection with Embedded Devices"/><published>2024-08-15T11:40:16+00:00</published><updated>2024-08-15T11:40:16+00:00</updated><id>https://r4hul77.github.io/blog/2024/wifi</id><content type="html" xml:base="https://r4hul77.github.io/blog/2024/wifi/"><![CDATA[<p>As an engineer working with embedded devices, I’ve often encountered situations where I needed to update Docker images on devices like the Jetson Xavier, which lacked a WiFi card due to size constraints in our DAQ kit. After hours of searching for a solution, I’ve compiled this guide to help others facing similar challenges. There are two main methods to share your laptop’s internet connection with an embedded device connected via Ethernet:</p> <ol> <li>Bridging: This method places the embedded device on the same local subnet as your laptop.</li> <li>NAT (Network Address Translation): Your laptop acts as a router, forwarding traffic between networks.</li> </ol> <h3 id="bridging">Bridging</h3> <p>On your laptop, run the following commands:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brctl addbr mybridge
brctl addif mybridge eth0
brctl addif mybridge wlan0
</code></pre></div></div> <p><strong>Note:</strong> This method may not work with all WiFi cards. If you encounter issues, delete the bridge using <code class="language-plaintext highlighter-rouge">brctl del mybridge</code> and proceed to the NAT method.</p> <h3 id="nat">NAT</h3> <h4 id="1-enable-ip-forwarding-on-your-laptop">1. Enable IP forwarding on your laptop:</h4> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo </span>1 <span class="o">&gt;</span> /proc/sys/net/ipv4/ip_forward
</code></pre></div></div> <p>For IPv6, replace ipv4 with ipv6 in the command.</p> <h4 id="2-set-up-iptables-rules">2. Set up iptables rules:</h4> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iptables <span class="nt">-t</span> nat <span class="nt">-A</span> POSTROUTING <span class="nt">-o</span> wlan0 <span class="nt">-j</span> MASQUERADE
iptables <span class="nt">-A</span> FORWARD <span class="nt">-i</span> wlan0 <span class="nt">-o</span> eth0 <span class="nt">-m</span> state <span class="nt">--state</span> RELATED,ESTABLISHED <span class="nt">-j</span> ACCEPT
iptables <span class="nt">-A</span> FORWARD <span class="nt">-i</span> eth0 <span class="nt">-o</span> wlan0 <span class="nt">-j</span> ACCEPT
</code></pre></div></div> <h4 id="3-configure-the-gateway-on-your-embedded-device-xavier-or-raspberry-pi">3. Configure the gateway on your embedded device (Xavier or Raspberry Pi):</h4> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> route add default gw 192.168.1.254 eth0
</code></pre></div></div> <h4 id="4-test-it-by-quickly-pining-an-external-ip-address">4. Test it by quickly pining an external ip address</h4> <p>With these steps, you should be able to run <code class="language-plaintext highlighter-rouge">sudo apt update</code> and resolve any issues without reinstalling the WiFi card on your embedded device. This guide provides a quick and efficient solution for sharing internet connections with embedded devices, saving time and effort in development and testing scenarios.</p>]]></content><author><name></name></author><category term="Jetson"/><category term="Pi"/><category term="Robotics"/><category term="Networking"/><category term="debugging"/><summary type="html"><![CDATA[A Quick Guide to Bridging and NAT]]></summary></entry><entry><title type="html">Let’s build an RQT plugin in ROS2</title><link href="https://r4hul77.github.io/blog/2024/RQT_plugin_cpp/" rel="alternate" type="text/html" title="Let’s build an RQT plugin in ROS2"/><published>2024-03-11T11:40:16+00:00</published><updated>2024-03-11T11:40:16+00:00</updated><id>https://r4hul77.github.io/blog/2024/RQT_plugin_cpp</id><content type="html" xml:base="https://r4hul77.github.io/blog/2024/RQT_plugin_cpp/"><![CDATA[<h2 id="1-introduction-to-ros2-and-rqt">1. Introduction to ROS2 and RQT</h2> <p>Since you’ve landed on this page, it’s safe to assume you have a grasp of what ROS2 (Robot Operating System 2) is. For the uninitiated, ROS2 is the next generation of ROS, providing a framework for writing software for robots that includes a collection of tools, libraries, and conventions aimed at simplifying the task of creating complex and robust robot behavior across a wide variety of robotic platforms. Now, let’s shift our focus to a particularly interesting and integral part of the ROS2 ecosystem - RQT.</p> <h3 id="what-is-rqt-and-its-importance-in-ros2">What is RQT and Its Importance in ROS2</h3> <p>Imagine if you could give your robots a brain transplant with just a few clicks. That’s RQT for you, a Qt-based plugin development in ROS that let’s you whip up a reuseable and scalable GUI application in a few minutes.</p> <h4 id="why-is-rqt-so-important-in-ros2"><strong>Why is RQT so important in ROS2?</strong></h4> <ol> <li> <p><strong>Versatility and Flexibility:</strong> Thanks to RQT’s plugin-based architecture, crafting new plugins is so easy that you might find yourself making one just for fun. And when you realize you’ve just saved yourself hours of head-scratching over terminal commands, you’ll want to bake a cake for RQT.</p> </li> <li> <p><strong>Improved User Experience:</strong> RQT is like the friendly robot in those sci-fi movies that translates alien tech into good ol’ human. Its graphical interface means you don’t need to decipher cryptic terminal texts anymore. It’s making robotics accessible to everyone, from the curious newbie to the seasoned engineer who’s seen one too many terminal screens.</p> </li> </ol> <h2 id="2-setting-the-stage-prerequisites-and-environment-setup">2. Setting the Stage: Prerequisites and Environment Setup</h2> <p>Alright, let’s roll up our sleeves and get down to business. First order of the day: make sure your Linux machine is all fired up and ready to go. And if you’re reading this from the cozy confines of Microsoft, no worries! The Windows Subsystem for Linux (WSL) has kinda got your back—just. I’m going to take a wild guess that you’ve got a handle on the basics of ROS2, including the sacred ritual of sourcing your environment. So, let’s skip the formalities and dive into the toolbox you’ll need to make some magic happen.T### The Journey Begins: Installing Qt</p> <p>First things first, grab the Qt installer from the official <a href="https://www.qt.io/download">Qt download page</a>. Once you’ve got that, it’s time to set things up:</p> <ol> <li>Open a terminal and navigate to the directory where you’ve downloaded the Qt installer.</li> <li> <p>Update the file permissions to make it executable with the following command:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">chmod</span> +x qt-unified-linux-x64-4.7.0-online.run
 ./qt-unified-linux-x64-4.7.0-online.run
</code></pre></div> </div> </li> <li> <p>Install the necessary Qt packages for your development environment:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">sudo </span>apt <span class="nb">install </span>qtbase5-dev qtchooser qt5-qmake qtbase5-dev-tools
</code></pre></div> </div> </li> </ol> <h3 id="setting-up-qt-creator-for-rqt-plugin-development">Setting Up Qt Creator for RQT Plugin Development</h3> <p>Now that Qt is installed, it’s time to fire up Qt Creator and start a new project:</p> <ol> <li>Open <strong>Qt Creator</strong> and select <strong>Create New Project</strong>.</li> <li>Navigate through the setup steps until you reach the <strong>Kit Selection</strong> tab. It’s here you’ll want to make a crucial choice: select <strong>Widget</strong> instead of <strong>QWindow</strong> for your project type, ensuring you’re on the right track for RQT plugin development.</li> </ol> <h4 id="navigating-the-qt-creator-setup">Navigating the Qt Creator Setup</h4> <p>Here’s a visual guide to help you through the setup process in Qt Creator:</p> <ul> <li>First, you’ll select the Widget option for your project, setting the stage for your plugin development.</li> <li>In the Kit Selection step, make sure your development kit is correctly configured. This might involve selecting a specific compiler or Qt version, depending on your system and ROS2 setup.</li> <li>Finally, you might need to manage your kits more directly, especially if you’re working in a specialized development environment. This could involve adding a new kit and configuring it to match your ROS2 development needs.</li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/rqt_cpp/widgets-480.webp 480w,/assets/img/posts/rqt_cpp/widgets-800.webp 800w,/assets/img/posts/rqt_cpp/widgets-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/posts/rqt_cpp/widgets.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/rqt_cpp/kits-480.webp 480w,/assets/img/posts/rqt_cpp/kits-800.webp 800w,/assets/img/posts/rqt_cpp/kits-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/posts/rqt_cpp/kits.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/rqt_cpp/kits_final-480.webp 480w,/assets/img/posts/rqt_cpp/kits_final-800.webp 800w,/assets/img/posts/rqt_cpp/kits_final-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/posts/rqt_cpp/kits_final.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h2 id="3-rqt-plugin-basics">3. RQT Plugin Basics</h2> <p>Welcome to the dojo of RQT plugins, where we mold the raw, chaotic energy of code into disciplined, user-friendly GUI applications. If RQT plugins were a martial art, consider this your white belt initiation.</p> <h3 id="understanding-rqt-plugin-architecture">Understanding RQT Plugin Architecture</h3> <p>Imagine RQT plugin architecture as a grand, bustling city. At its heart lies the main application (let’s call it the Mayor), which manages all the little plugin citizens. Each plugin is like a specialized shop in this city, offering unique services (widgets) that can be used independently or combined to create something greater, much like a thriving marketplace.</p> <p>This city is built on the solid ground of Qt, with roads paved by ROS2, ensuring all plugins can communicate seamlessly, sharing topics and services like gossip across backyard fences. The architecture is designed to be modular; you can add or remove plugins without disrupting the city’s harmony. It’s urban planning at its finest, but for robots.</p> <h4 id="the-plugin-manifesto-a-declaration-of-independence">The Plugin Manifesto: A Declaration of Independence</h4> <p>Every plugin comes with a manifesto (the plugin.xml file), declaring its intentions, capabilities, and how it wishes to be recognized by the Mayor (the main application). This document ensures that every plugin plays nice and can be easily found and integrated into the bustling city life.</p> <h3 id="core-components-of-an-rqt-plugin">Core Components of an RQT Plugin</h3> <p>Breaking down an RQT plugin, we find it’s not just a single entity but a team of components working in harmony:</p> <ol> <li> <p><strong>The GUI (Graphical User Interface):</strong> This is the face of your plugin, the part users will interact with. It’s like the shopfront, inviting and easy to navigate.</p> </li> <li> <p><strong>Backend Logic:</strong> The brain behind the operation, handling the heavy lifting, computations, and ROS communications. It’s the shopkeeper, managing transactions and making sure the customer (user) leaves happy.</p> </li> <li> <p><strong>Plugin.xml Manifest:</strong> As mentioned, this is your plugin’s ID, business license, and billboard all rolled into one, ensuring it gets the recognition it deserves.</p> </li> <li> <p><strong>Initialization Script:</strong> This is the ribbon-cutting ceremony for your plugin. It tells RQT how to start your plugin and integrate it into the grand scheme of things.</p> </li> </ol> <p>Think of crafting an RQT plugin as opening a shop in the city of ROS2. Your goal is to provide a service, attract customers (users), and contribute to the city’s (ROS community’s) growth. With the right combination of GUI charm and backend brains, your plugin could become the next big thing in the RQT cityscape.</p> <p>So, grab your hard hat and blueprint. It’s time to build some plugins.</p> <h2 id="4-designing-your-rqt-plugin-the-simple-logger">4. Designing Your RQT Plugin: The Simple Logger</h2> <p>Embarking on the creation of a Simple Logger RQT plugin is like setting up a diary for your robot, but instead of secrets, it’s filled with log messages. This section will guide you through planning its functionality, considering the UI design, and leveraging Qt Designer to bring it all to life. Eventhough rqtconsole exists let’s assume that it doesn’t for this tutorial.</p> <h3 id="planning-your-plugins-functionality">Planning Your Plugin’s Functionality</h3> <p>Before we start doodling our UI, let’s establish what our Simple Logger needs to do. At its core, the plugin should:</p> <ul> <li><strong>Capture and display ROS log messages:</strong> It should listen for log messages from your ROS system and display them in real time.</li> <li><strong>Offer log message filtering:</strong> Users should be able to filter the displayed messages based on severity levels such as DEBUG, INFO, WARN, ERROR, and FATAL.</li> <li><strong>Provide user control over the log display:</strong> A pause/resume feature will help users stop the flood of messages when they need to focus on specific information.</li> </ul> <h3 id="ui-design-considerations-for-rqt-plugins">UI Design Considerations for RQT Plugins</h3> <p>When designing the UI for our Simple Logger, keep these principles in mind:</p> <ul> <li><strong>Simplicity and Clarity:</strong> The main goal is to read log messages easily. A clean and straightforward layout will help users find the information they need without distractions.</li> <li><strong>Usability:</strong> Features like filtering and pausing the message stream should be intuitive to use. Think about placing these controls within easy reach and making their functions obvious.</li> <li><strong>Responsiveness:</strong> The UI should handle updates smoothly, without lag or jank, even when bombarded with a high volume of log messages.</li> </ul> <h3 id="leveraging-qt-designer-for-ui-development">Leveraging Qt Designer for UI Development</h3> <p>Qt Designer will be our trusty sidekick in creating the UI for our Simple Logger. Here’s a step-by-step approach to using it effectively:</p> <ol> <li><strong>Lay Out the Main Components:</strong> -Drag a <code class="language-plaintext highlighter-rouge">Vertical Layout</code> <ul> <li>Drag a <code class="language-plaintext highlighter-rouge">QTextEdit</code> widget into the central area. This will be where the log messages are displayed.</li> <li>Now Drag a <code class="language-plaintext highlighter-rouge">Horizontal Layout</code> and Horizonatal spacer to it.</li> <li>Add a <code class="language-plaintext highlighter-rouge">QComboBox</code> or a panel of <code class="language-plaintext highlighter-rouge">QPushButton</code>s for the log level filters and the pause/resume feature.</li> <li>Your layout should look like the image below.</li> </ul> </li> </ol> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/rqt_cpp/layout_final-480.webp 480w,/assets/img/posts/rqt_cpp/layout_final-800.webp 800w,/assets/img/posts/rqt_cpp/layout_final-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/posts/rqt_cpp/layout_final.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <ol> <li><strong>Customize the Widgets:</strong> <ul> <li>For the <code class="language-plaintext highlighter-rouge">QTextEdit</code>, enable read-only mode to prevent users from editing the log messages directly.</li> <li>Customize the buttons or toolbar actions to represent different log levels and control features (e.g., icons for pause/resume, dropdown for filter levels).</li> </ul> </li> <li><strong>Set Object Names:</strong> <ul> <li>Assign meaningful object names to your UI components. This will help you reference them easily in your cpp code when you need to update the UI or handle user actions.</li> </ul> </li> <li><strong>Preview and Adjust:</strong> <ul> <li>Use the preview feature in Qt Designer to see how your UI looks and behaves. Adjust sizes, layouts, and styles until you’re satisfied with the design.</li> </ul> </li> </ol> <p>Following these steps, you’ll craft a UI that’s not just functional but also a joy to use. With the planning and design phase wrapped up, you’re now ready to breathe life into your Simple Logger, turning lines of code into a valuable tool for ROS enthusiasts.</p> <h2 id="5-next-up-integrating-it-with-ros2-and-all-the-other-nice-stuff">5. Next Up Integrating it with ROS2 and all the other nice stuff.</h2>]]></content><author><name></name></author><category term="ROS2"/><category term="ROS2"/><category term="Robotics"/><category term="C++"/><summary type="html"><![CDATA[Learn to build a RQT Plugin in C++]]></summary></entry></feed>